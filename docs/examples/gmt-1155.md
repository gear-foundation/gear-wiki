---
sidebar_label: 'GMT (ERC-1155)'
sidebar_position: 5
---

# Gear Multiple Token

## Introduction

A standard interface for contracts that manage multiple token types. A single deployed contract may include any combination of fungible tokens, non-fungible tokens or other configurations (e.g. semi-fungible tokens).

The idea is simple and seeks to create a smart contract interface that can represent and control any number of fungible and non-fungible token types. In this way, the GMT token can do the same functions as a GFT and GNFT token, and even both at the same time. Can be considered as analog of ERC-1155.

## Interface

### Events Structure

```rust
pub type TokenId = u128;

#[derive(Debug, Encode, Decode, TypeInfo)]
pub struct BalanceReply {
    pub account: ActorId,
    pub id: TokenId,
    pub amount: u128,
}

#[derive(Debug, Encode, Decode, TypeInfo)]
pub enum MTKEvent {
    // `Transfer` MUST emit when tokens are transferred including zero value transfers as well as minting por burning.
    // Event is the same for a single-mint/burn/transfer operation as well as for a batch operation. The only difference is the length of ids and amounts vectors (=1 in case of a single token operation).
    Transfer {
        operator: ActorId,
        from: ActorId,
        to: ActorId,
        ids: Vec<TokenId>,
        amounts: Vec<u128>,
    },

    // `BalanceOf` MUST emit when ActorID's balance is requested.
    // Event is the same for a single ActorID balance retrival as well as for a batch version.
    BalanceOf(Vec<BalanceReply>),

    // `Approval` MUST emit when an ActorID is approved to perform operations with the specific tokens on behalf of the owner.
    Approval {
        from: ActorId,
        to: ActorId,
    },

    // `RevokeApproval` MUST emit when an ActorID is disapproved to perform operations with the specific tokens on behalf of the owner.
    RevokeApproval {
        from: ActorId,
        to: ActorId,
    },
}
```

### Functions

```rust
// Get the balance of single/multiple accounts (single and batch version at the same time).
fn balance_of(&self, accounts: Vec<ActorId>, ids: Vec<TokenId>);

// Mint token/multiple tokens to an account (single and batch version at the same time).
fn mint(
    &mut self,
    account: &ActorId,
    ids: Vec<TokenId>,
    amounts: Vec<u128>,
    meta: Vec<Option<TokenMetadata>>,
);

// Burn token/multiple tokens from an account (single and batch version at the same time).
fn burn(&mut self, ids: Vec<TokenId>, amounts: Vec<u128>);

// Transfer token/multiple tokens between Actors (single and batch version at the same time).
fn transfer_from(
    &mut self,
    from: &ActorId,
    to: &ActorId,
    ids: Vec<TokenId>,
    amounts: Vec<u128>,
);

// Gives a right to another account to manage sender's tokens.
fn approve(&mut self, to: &ActorId);

// Removes a right from another account to manage sender's toekns.
fn revoke_approval(&mut self, to: &ActorId);
```

### Init Config

```rust
pub struct InitConfig {
    pub name: String,
    pub symbol: String,
    pub base_uri: String,
}
```

### Example of `Action` Structure

```rust
#[derive(Debug, Encode, Decode, TypeInfo)]
pub enum MyMTKAction {
    Mint {
        amount: u128,
        token_metadata: Option<TokenMetadata>,
    },
    Burn {
        id: TokenId,
        amount: u128,
    },
    BalanceOf {
        account: ActorId,
        id: TokenId,
    },
    BalanceOfBatch {
        accounts: Vec<ActorId>,
        ids: Vec<TokenId>,
    },
    MintBatch {
        ids: Vec<TokenId>,
        amounts: Vec<u128>,
        tokens_metadata: Vec<Option<TokenMetadata>>,
    },
    TransferFrom {
        from: ActorId,
        to: ActorId,
        id: TokenId,
        amount: u128,
    },
    BatchTransferFrom {
        from: ActorId,
        to: ActorId,
        ids: Vec<TokenId>,
        amounts: Vec<u128>,
    },
    BurnBatch {
        ids: Vec<TokenId>,
        amounts: Vec<u128>,
    },
    Approve {
        account: ActorId,
    },
    RevokeApproval {
        account: ActorId,
    },
}
```

## Conclusion

A source code of the base lib providing multitoken functionality provided by Gear is available on GithHub: [`gear-contract-libraries/src/multitoken`](https://github.com/gear-tech/apps/tree/master/gear-contract-libraries/src/multitoken).

A source code of the contract example provided by Gear is available on GitHub: [`multitoken`](https://github.com/gear-tech/apps/tree/master/multitoken).

See also an example of the smart contract testing implementation based on gtest: [`multitoken/tests/mtk_tests.rs`](https://github.com/gear-tech/apps/blob/master/multitoken/tests/mtk_tests.rs).

For more details about testing smart contracts written on Gear, refer to this article: [Program testing](https://wiki.gear-tech.io/developing-contracts/testing).
