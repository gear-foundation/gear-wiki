---
sidebar_label: 'Actor 模型'
sidebar_position: 4
---

# Actor 模型

在并行计算系统中，“消息通信”方法意味着程序通过消息交换进行通信。它比“共享内存通信”更具有优势。 消息传递并发比共享内存并发更容易理解。它通常被认为更健壮，比共享内存具有更好的性能。

对于进程间通信，Gear 使用 Actor 模型方案。Actor 模型的原则是，程序从不共享任何状态，只是在彼此之间交换信息。

通过 Actor 模型，系统由同时运作的对象组成，这些对象之间完全通过消息传递进行交流。虽然普通的 Actor 模型不保证消息的顺序，但 Gear 提供了一些额外的保证，即两个特定程序之间的消息的顺序被保留下来。

在 Actor 模型中，一个系统由同时运作的功能对象组成，这些对象之间完全通过消息传递进行通信。虽然一般 Actor 模型并不保证消息的顺序，但 Gear 提供了一些额外的保证，即两个特定程序之间的消息顺序被保存下来。

Actor 模型保障了高可扩展性和高容错性。

## Actor

Actor 模型中的 Actor 是可以发送和接收消息的原子计算单元。在 Gear 中，Actor 是一个程序(智能合约)或向程序发送消息的用户。每个 Actor 都有一个内部私有状态和一个信箱。通信是异步的，消息从信箱中弹出并分配给消息处理流，在那里按周期处理。

当一个 Actor 收到并处理一个消息时，可以响应以下内容：

- 向另一个 Actor 发送消息
- 创建另一个 Actor
- 改变自己的内部状态

Actor 是独立的，它们从不分享任何状态，只是相互交换信息。

使用 Actor 模型方案提供了一种在程序（智能合约）逻辑中实现基于 Actor 的并发性的方法。 它可以利用各种语言构造进行异步编程（Rust 中的 Futures 和 async-await）。

## Async/await 支持

与类不同，actor 一次只允许一个任务访问它们的可变状态，这使得多个任务中的代码可以安全地与同一个 actor 实例交互。

异步函数大大简化了并发管理，但它们无法处理死锁或状态损坏的情况。为了避免死锁或状态损坏，异步函数应该避免调用可能阻塞其线程的函数。为了实现这一点，他们选择使用 await 表达式。

目前，典型的智能合约代码中缺乏对 async/await 模式的支持，这给智能合约开发人员带来了很多问题。实际上，通过手工添加函数（在 Solidity 智能合约中），以在智能合约程序流中实现更好的控制的方式, 或多或少是可行的。但是问题在于，一些合约中的函数会让人们很容易混淆在合约生命周期中的哪个阶段可以调用哪个函数。

Gear 为程序提供了通用的 async/await 语法。它极大地简化了开发和测试，并减少了智能合约开发中出错的可能性。如果程序逻辑需要，Gear API也允许通过简单地不使用await表达式来使用同步消息。