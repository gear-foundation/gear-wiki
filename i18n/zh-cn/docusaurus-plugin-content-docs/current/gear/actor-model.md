---
sidebar_label: 'Actor model'
sidebar_position: 3
---

# Gear 的 Actor 模型

在并发计算系统中，“消息传递通信”方法意味着程序通过消息交换进行通信。它比“共享内存通信”更具有优势。 消息传递并发比共享内存并发更容易理解。它通常被认为更健壮，比共享内存具有更好的性能。

对于进程间通信，Gear 使用了 Actor 模型方法--描述消息传递系统的众多数学理论之一。Actor 模型的普及率越来越高，它已被用于许多新的编程语言中。Actor 模型的原则是，程序从不共享任何状态，只是在彼此之间交换信息。

在 Actor 模型中，一个系统由同时运作的对象组成，这些对象之间完全通过消息传递进行交流。虽然普通的 Actor 模型并不保证消息的顺序，但 Gear 提供了一些额外的保证，即两个特定程序之间的消息顺序被保留下来。

Actor 模式保证了：

- 高可扩展性
- 高容错性

## Actor

Actor 模型中的 Actor 是可以发送和接收消息的原子计算单元。在 Gear 中，参与者是一个程序(智能合约)或向程序发送消息的用户。每个参与者都有一个内部私有状态和一个信箱。通信是异步的，消息从信箱中弹出并分配给消息处理流，在那里按周期处理。

当一个 actor 收到并处理一个消息时，可以响应以下内容：

- 向另一个 actor 发送消息
- 创建另一个 actor
- 改变自己的内部状态

Actor 是独立的，他们从不分享任何状态，只是相互交换信息。

使用 Actor 模型方法提供了一种在程序（智能合约）逻辑中实现基于 Actor 的并发性的方法。 它可以利用各种语言构造进行异步编程（Rust 中的 Futures 和 async-await）。

## Async/await 支持

与类不同，actor 一次只允许一个任务访问它们的可变状态，这使得多个任务中的代码可以安全地与同一个 actor 实例交互。

异步函数大大简化了并发管理，但它们无法处理死锁或状态损坏的情况。为了避免死锁或状态损坏，异步函数应该避免调用可能阻塞其线程的函数。为了实现这一点，他们选择使用 await 表达式。

目前，典型的智能合约代码中缺乏对 async/await 模式的支持，这给智能合约开发人员带来了很多问题。实际上，通过添加手工函数（在 Solidity 智能合约中），在智能合约程序流中实现更好的控制，或多或少是可能的。但是合约中许多函数的问题在于，人们很容易混淆，在合约生命周期中的哪个阶段可以调用哪个函数。

Gear 为程序提供了通用的 async/await 语法。这大大简化了开发和测试过程，降低了智能合约开发中出错的可能性。如果程序逻辑需要，Gear API 还允许不使用 await 表达式来使用同步消息。
