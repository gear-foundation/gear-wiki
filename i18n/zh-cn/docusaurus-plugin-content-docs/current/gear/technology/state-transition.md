---
sidebar_position: 6
sidebar_label: '状态转移'
---

# 状态转移

每个系统都遵循系统状态演变所依据的规则。当网络处理新的输入数据时，状态会根据状态转换规则前进。这些输入数据被打包在被称为交易 (transactions) 的细粒度信息中。

Gear 节点维护和同步一个交易池，其中包含所有新交易。当任何节点（无论是否为验证者）收到一个交易时，该节点会将这个交传播给所有连接的节点。关于交易池如何运作的更高级内容，请参考 [Substrate 文档](https://substrate.dev/docs/en/knowledgebase/learn-substrate/tx-pool) 。链接替换为 https://docs.substrate.io/v3/concepts/tx-pool/

当 Gear 验证节点生成新块时，池中的一些（或所有）交易将合并到一个区块中，网络将通过该块进行状态转换。在生成下一个块之前，上一个块中未打包的交易将保留在池子中，直到下一个区块产生。

Gear 支持以下类型的交易：

1. **创建程序 (program)** : 用户上传新的程序（智能合约）
2. **发送消息** : 程序或用户将新消息放入消息队列
3. **取出消息** : 验证者（块生产者）从消息队列取出多条消息，运行其对应的程序
4. **余额交易** : Gear 引擎执行"用户<—>程序<—>验证者"之间的余额交易

消息处理是在区块的构建/导入时保留的时间窗口内进行的。它保证消息处理将在每个块中执行，并且至少以基于当前实例设置的某一确定速率执行。

:::tip

这里的**速率**指的是在构建区块时，由于区块的 gas limit 是有限的，所以不一定会在一个块中执行所有队列中的消息，但是 Gear 会基于 gas limit 是否达到来尽可能处理消息，即处理消息的速率至少会基于当前实例的设置来保证

:::

### 创建程序

Gear 网络中的指定机构（或任何公开实现用户）可以提交新的程序 (program) 来存入 Gear 网络的世界状态。对于网络公开部分，同时提供了一个与程序关联的余额参数，这个新的余额将会设置为初始余额（存在抵押）。( 参考[`submit_program`](https://github.com/gear-tech/gear/blob/master/pallets/gear/src/lib.rs#L736) )

### 发送消息

终端用户与程序进行的互动，从结果来看就是向 Gear 网络发送消息。发送到 Gear 网络的消息将会进入全局消息队列。这个队列可以被看作是一个由运行时 (runtime) 驱动的交易队列，它保证任何被其接受并存入的消息最终都会被处理。将消息放入队列的过程并非完全自由的，因为要保证消息可以被正确分发。

### 消息出列

当轮到验证者产生下一个区块时，验证者可以选择让哪些消息出列。它消除了每个特定验证器维护完整内存状态的需要。出列仅发生在每个出块过程的末尾。在处理队列的期间，也可以生成新的消息。这些新消息既可以在这个阶段就被处理，也可以留在队列中等待下一个块（和另一个验证器）来处理。( 可以参考[`process_queue`](https://github.com/gear-tech/gear/blob/master/pallets/gear/src/lib.rs#L278)来理解 )

### 余额交易

常规余额交易是在 Substrate 的 Balance 模块中进行的。

### 消息、区块和事件的生命周期

下图说明了 Gear 的全生命周期。正如面向通信领域的 actor 模型所规定的，除了消息可以共享，再没有任何东西是可以共享的了。以 "系统" 为目的地的消息最终会出现在事件日志中，以便在用户空间进行检查。

![alt text](/assets/mq.jpg)
